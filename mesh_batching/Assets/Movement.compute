#pragma kernel CSMain

struct MeshProperties { 
    float4x4 mat;
    float4 color;

	// ------------------------------
	float3 cohVector;
	float3 alignVector;
	float3 avoidVector;
	// ------------------------------
};

RWStructuredBuffer<MeshProperties> _Properties; 
float3 _PusherPosition; 

// ------------------------------
float _distanceFromPusher;
float _awaySpeed;
float _radius;

float _cohWeight;
float _alignWeight;
float _avoidWeight;

float _deltaTime;
int _population;
float3 _maxCohVector;
float _avoidanceRadius; // avoidanceRadius < _radius 
// ------------------------------

// ------------------------------
// myIndex에 해당하는 agent의 position을 구해준다. 
float3 getAgentPosition(int myIndex, RWStructuredBuffer<MeshProperties> _Properties)
{
	float4x4 mat = _Properties[myIndex].mat;
	float3 myPosition = float3(mat[0][3], mat[1][3], mat[2][3]);
	return myPosition;
}

// 'Cohesion' function of the 'Crowd Member' class 
// main () 에서 id.x 로 각 index 를 가져오므로, 각 index 에 대한 cohVector 구하는 것으로 이해. 
float3 getCohVector(int myIndex, RWStructuredBuffer<MeshProperties> _Properties, float _radius, int _population, float3 _maxCohVector)
{
	float4x4 mat = _Properties[myIndex].mat;
	float3 myPosition = float3(mat[0][3], mat[1][3], mat[2][3]);

	float neighborCount = 0;

	float3 cohVector = float3(0, 0, 0);
	float3 prevcohVector = _Properties[myIndex].cohVector;

	for (int index = 0; index < _population; index++)
	{
		float3 otherAgentPosition = getAgentPosition(index, _Properties);
		if (distance(myPosition, otherAgentPosition) < _radius)
		{
			cohVector += otherAgentPosition;
			neighborCount += 1;
		}
	}
	if (neighborCount == 0)
	{
		return float3(0, 0, 0);
	}

	cohVector /= neighborCount;
	cohVector -= myPosition;
	cohVector = smoothstep(cohVector, 0, _maxCohVector);

	return cohVector;
}

// 'Alignment' function of the 'Crowd Member' class
float3 getAlignVector(int myIndex, RWStructuredBuffer<MeshProperties> _Properties, float _radius, int _population)
{
	float4x4 mat = _Properties[myIndex].mat;
	float3 myPosition = float3(mat[0][3], mat[1][3], mat[2][3]);
	float3 myForward = float3(mat[0][2], mat[1][2], mat[2][2]);

	float3 alignVector = float3(0, 0, 0);
	float neighborCount = 0;

	for (int index = 0; index < _population; index++)
	{
		float3 otherAgentPosition = getAgentPosition(index, _Properties);

		if (distance(myPosition, otherAgentPosition) < _radius)
		{
			alignVector += myForward;
			neighborCount += 1;
		}
	}

	if (neighborCount == 0)
	{
		return myForward;
	}

	alignVector /= neighborCount;

	return alignVector;
}

// 'Avoidance' function of the 'Crowd Member' class
float3 getAvoidVector(int myIndex, RWStructuredBuffer<MeshProperties> _Properties, float _radius, int _population, float _avoidanceRadius)
{
	float4x4 mat = _Properties[myIndex].mat;
	float3 myPosition = float3(mat[0][3], mat[1][3], mat[2][3]);

	float3 avoidVector = float3(0, 0, 0);  
	int nAvoid = 0;

	for (int index = 0; index < _population; index++)
	{
		float3 otherAgentPosition = getAgentPosition(index, _Properties);
		// undeclared identifier 'avoidacneRadius' at kernel CSMain
		if (distance(myPosition, otherAgentPosition) < _avoidanceRadius)
		{
			avoidVector += myPosition - otherAgentPosition;
			nAvoid += 1;
		}
	}

	if (nAvoid > 0)
	{
		avoidVector /= nAvoid;
	}

	return avoidVector;
}
//// ------------------------------
// floating point division by zero at kernel CSMain
// We used to just be able to use (1, 1, 1) threads for whatever population (not sure the old limit), but a Unity update
// imposed a thread limit of 65535.  Now, to render populations above that, we need to be more granular with our threads.

[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
	// original code : 
	float4x4 mat = _Properties[id.x].mat;
	float3 position = float3(mat[0][3], mat[1][3], mat[2][3]);

	//// ------------------------------
	float3 cohVector = getCohVector(id.x, _Properties, _radius, _population, _maxCohVector);
	float3 alignVector = getAlignVector(id.x, _Properties, _radius, _population);
	float3 avoidVector = getAvoidVector(id.x, _Properties, _radius, _population, _avoidanceRadius);

	// original code : 
	float dist = distance(position, _PusherPosition);
	// Scale and reverse distance so that we get a value which fades as it gets further away.
	// Max distance is 5.0.
	// dist = 5.0 - clamp(0.0, 5.0, dist);

	float3 awayVector;
	float3 awayDir;

	// variable '_distanceFromPusher' used without having been completely initialized at kernel CSMain
	if (dist < _distanceFromPusher)
	{
		awayDir = normalize(position - _PusherPosition);
		awayVector = awayDir * _awaySpeed;
	}
	else
	{
		awayVector = float3(0, 0, 0);
	}

	float3 moveVector = _cohWeight * cohVector + _alignWeight * alignVector + _avoidWeight * avoidVector + _awaySpeed * awayVector;
	float3 nextPosition = moveVector * _deltaTime;

	_Properties[id.x].mat[0][3] = nextPosition.x;
	_Properties[id.x].mat[1][3] = nextPosition.y;
	_Properties[id.x].mat[2][3] = nextPosition.z;
	// ------------------------------
}
